{%- import "cloudevents.jinja.include" as cloudEvents %}
{%- import "kafka.jinja.include" as kafka %}
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = (root | exists( "format", "cloudevents" )) %}
{%- set uses_plain_kafka_message = (root | exists( "binding", "kafka" )) %}
{%- set uses_kafka_endpoint = (root | exists( "protocol", "kafka" )) %}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

#nullable enable

using Confluent.Kafka;
using Microsoft.Extensions.Logging;
using {{ project_name | pascal }}.Tools;
{%- if uses_cloudevents_message %}
{{ kafka.CloudEventsUsings() }}
{%- endif %}

namespace {{ project_name | pascal }}
{
    {% for messagegroup_key, messagegroup in messagegroups.items() -%}
    {%- set uses_cloudevents_message = (messagegroup | exists( "format", "cloudevents" )) %}
    {%- set uses_plain_kafka_message = (messagegroup | existswithout( "binding", "kafka", "format", "cloudevents" )) %}
    {%- set pascalGroupName = messagegroup.id  | pascal -%}
    {%- set class_name = ( pascalGroupName | strip_namespace )+"EventDispatcher" %}
    namespace {{ pascalGroupName | pascal  }}
    {
        public class {{ class_name }} : DispatcherBase
        {
            {%- if (messagegroup | exists( "format", "cloudevents" )) %}

            {%- endif %}
            {%- for id, message in messagegroup.messages.items() -%}
            {%- set pascalDefinitionName = message.id | strip_namespace | pascal -%}
            {%- if message.schemaurl or message.schema -%}
            {%- set dataType = 'global::' + (( message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) | pascal) -%}
            {%- else -%}
            {%- set dataType = "object" -%}
            {%- endif %}
            {%- if message.description %}
            /// <summary>
            /// {{ message.description }}
            /// </summary>
            {%- endif %}
            {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) -%}
            {%- set isKafka = (message | existswithout( "binding", "kafka", "format", "cloudevents" )) %}
            public event Func<ConsumeResult<byte[], byte[]>, {% if isCloudEvent %}CloudEvent?, {% endif %}{{ dataType }}?, Task>? {{ pascalDefinitionName | strip_namespace }}Async;
            {%- endfor %}
            public event Func<ConsumeResult<byte[], byte[]>, Task>? UnhandledMessageAsync;

            public {{ class_name }}(ILoggerFactory? loggerFactory = null) : base(loggerFactory?.CreateLogger<{{ class_name }}>() ?? new LoggerFactory().CreateLogger<{{ class_name }}>())
            {
            }

            internal override async Task<bool> ProcessMessageAsync(ConsumeResult<byte[], byte[]> messageArgs)
            {
                _logger.LogInformation($"Processing message from partition {messageArgs.Partition}");
                {%- if uses_cloudevents_message %}
                if (IsCloudEvent(messageArgs.Message))
                {
                    var cloudEvent = CloudEventFromMessage(messageArgs.Message);
                    if (await DispatchCloudEventAsync(messageArgs, cloudEvent))
                    {
                        return true;
                    }
                }
                {%- else %}
                var message = messageArgs.Message;
                if (message != null)
                {
                    if (await DispatchMessageAsync(messageArgs))
                    {
                        return true;
                    }
                }
                {%- endif %}
                if (UnhandledMessageAsync != null)
                {
                    await UnhandledMessageAsync(messageArgs);
                }
                return false;
            }

            {%- if uses_cloudevents_message %}
            protected virtual async Task<bool> DispatchCloudEventAsync(ConsumeResult<byte[], byte[]> messageArgs, CloudEvent cloudEvent)
            {
                var cloudEventType = cloudEvent.Type;
                _logger.LogInformation($"Dispatching CloudEvent of type {cloudEventType}");
                switch (cloudEventType)
                {
                    {% for id, message in messagegroup.messages.items() -%}
                    {%- set pascalDefinitionName = message.id | pascal %}
                    {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) -%}
                    {%- if message.schemaurl or message.schema -%}
                    {%- set dataType = 'global::' + (( message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat)  | pascal) -%}
                    {%- else -%}
                    {%- set dataType = "object" -%}
                    {%- endif %}
                    case "{{ message.id }}":
                        if ({{ pascalDefinitionName | strip_namespace }}Async != null)
                        {
                            await Task.WhenAll(Array.ConvertAll({{ pascalDefinitionName | strip_namespace }}Async.GetInvocationList(), e => (Task)(e.DynamicInvoke(messageArgs,
                            {%- if isCloudEvent %}cloudEvent, {%- endif %}
                            {%- if dataType != "object" -%}{{ dataType }}.FromData(cloudEvent.Data, cloudEvent.DataContentType){%- else -%}cloudEvent.Data{%- endif %}) ?? Task.CompletedTask)));
                        }
                        return true;
                    {%- endfor %}
                    default:
                        return false;
                }
            }
            {%- endif %}

            {%- if uses_plain_kafka_message %}
            protected virtual async Task<bool> DispatchMessageAsync(ConsumeResult<byte[], byte[]> messageArgs)
            {
                var messageSubject = messageArgs.Message.Headers.FirstOrDefault(h => h.Key == "subject")?.GetValueBytes() != null
                    ? Encoding.UTF8.GetString(messageArgs.Message.Headers.FirstOrDefault(h => h.Key == "subject")?.GetValueBytes())
                    : null;
                _logger.LogInformation($"Dispatching message with subject {messageSubject}");
                switch (messageSubject)
                {
                {% for id, message in messagegroup.messages.items() if ((message | exists("binding", "kafka" )) and not (message | exists("format", "cloudevents" ))) -%}
                {%- set pascalDefinitionName = message.id | pascal %}
                {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) -%}
                {%- if message.schemaurl or message.schema -%}
                {%- set dataType = 'global::' + (( message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat)  | pascal) -%}
                {%- else -%}
                {%- set dataType = "object" -%}
                {%- endif %}
                    case "{{ message.id }}":
                        if ({{ pascalDefinitionName | strip_namespace }}Async != null)
                        {
                            await Task.WhenAll(Array.ConvertAll({{ pascalDefinitionName | strip_namespace }}Async.GetInvocationList(), e => (Task)(e.DynamicInvoke(messageArgs,
                        {%- if isCloudEvent %}null, {% endif %}
                        {%- if dataType != "object" -%}{{ dataType }}.FromData(messageArgs.Message.Value, messageArgs.Message.Headers.FirstOrDefault(h => h.Key == "content-type")?.GetValueBytes() != null ? Encoding.UTF8.GetString(messageArgs.Message.Headers.FirstOrDefault(h => h.Key == "content-type")?.GetValueBytes()) : null){%- else -%}messageArgs.Message.Value.ToObject<{{ dataType }}>(){%- endif %}) ?? Task.CompletedTask)));
                        }
                        return true;
                {%- endfor %}
                    default:
                        return false;
                }
            }
            {%- endif %}

            public KafkaProcessor<byte[], byte[]> CreateKafkaProcessor(ConsumerConfig config, string topicName)
            {
                var consumer = new ConsumerBuilder<byte[], byte[]>(config).Build();
                var processor = new KafkaProcessor<byte[], byte[]>(consumer, topicName);
                processor.Attach(this);
                return processor;
            }
        }
    }

    {% set dispatcherBase = "global::"+( project_name | pascal )+".Tools.DispatcherBase" %}
    public static class {{ class_name }}ProcessorExtensions
    {
        private static readonly Dictionary<KafkaProcessor<byte[], byte[]>, List<{{ dispatcherBase }}>> Dispatchers =
            new Dictionary<KafkaProcessor<byte[], byte[]>, List<{{ dispatcherBase }}>>();

        public static void Attach(this KafkaProcessor<byte[], byte[]> processor, {{ dispatcherBase }} dispatcher)
        {
            if (!Dispatchers.ContainsKey(processor))
            {
                Dispatchers[processor] = new List<{{ dispatcherBase }}>();
                processor.ProcessMessage += async (messageArgs) => await ProcessMessageAsync(processor, messageArgs);
                processor.ProcessError += async (error) => await ProcessErrorAsync(processor, error);
            }
            Dispatchers[processor].Add(dispatcher);
        }

        public static void Detach(this KafkaProcessor<byte[], byte[]> processor, {{ dispatcherBase }} dispatcher)
        {
            if (Dispatchers.ContainsKey(processor))
            {
                Dispatchers[processor].Remove(dispatcher);
                if (Dispatchers[processor].Count == 0)
                {
                    Dispatchers.Remove(processor);
                }
            }
        }

        private static async Task ProcessMessageAsync(KafkaProcessor<byte[], byte[]> processor, ConsumeResult<byte[], byte[]> messageArgs)
        {
            foreach (var dispatcher in Dispatchers[processor])
            {
                if (await dispatcher.ProcessMessageAsync(messageArgs))
                {
                    return;
                }
            }
        }

        private static async Task ProcessErrorAsync(KafkaProcessor<byte[], byte[]> processor, Exception error)
        {
            foreach (var dispatcher in Dispatchers[processor])
            {
                await dispatcher.ProcessErrorAsync(error);
            }
        }
    }

    {% endfor %}

    {%- if root.endpoints -%}
    {%- for endpoint_key in root.endpoints.keys() -%}
    {%- set endpoint = root.endpoints[endpoint_key] -%}
    {%- set pascalGroupName = endpoint.id | default(endpoint_key) | pascal -%}
    {%- if endpoint.usage == "consumer" -%}
    {%- set protocol = endpoint.config.protocol | lower -%}
    {%- if protocol.startswith("kafka") -%}
    {%- set options = endpoint.config.options -%}
    {%- set endpoints = endpoint.config.endpoints -%}
    {%- set messagegroupuris = endpoint.messagegroups %}
    {%- macro MessageGroupArgs() -%}
    {%- for uri in messagegroupuris %}
    {%- set group = schema_object( root, uri ) -%}
    {%- if group %}
    {%- set groupname = group.id | pascal -%}
    {{ groupname }}EventDispatcher? {{ groupname | strip_namespace | camel }}Dispatcher = null
    {%- if not loop.last -%}, {%- endif -%}
    {%- endif %}
    {%- endfor %}
    {%- endmacro -%}
    {%- macro MessageGroupHooks(arg) -%}
    Task.WhenAll(
    {%- for uri in messagegroupuris %}
    {%- set group = schema_object( root, uri ) -%}
    {% if group %}
    {%- set groupname = group.id | pascal -%}
    {{- groupname | strip_namespace | camel }}Dispatcher != null?{{- groupname | strip_namespace | camel }}Dispatcher.ProcessMessageAsync({{ arg }}):Task.CompletedTask
    {%- if not loop.last -%}, {%- endif -%}
    {%- endif %}
    {%- endfor %}
    )
    {%- endmacro -%}
    {%- macro createforbody(class_name, endpoints, options) -%}
        {%- set kafkatopic = geturlpath(endpoints[0].uri)[1:] -%}
        var consumer = new ConsumerBuilder<byte[], byte[]>(config).Build();
        var processor = new KafkaProcessor<byte[], byte[]>(consumer, _loggerFactory);
        processor.Attach(this);
        return processor;
    {%- endmacro %}

    namespace {{ pascalGroupName | namespace(project_name) | pascal }}
    {
        {%- set class_name = ( pascalGroupName | strip_namespace )+"KafkaProcessorFactory" %}
        public class {{ class_name }}
        {
            public static KafkaProcessor<byte[], byte[]> CreateKafkaProcessorFor{{ endpoint_key | pascal | strip_namespace }}(ConsumerConfig config, {{ MessageGroupArgs() }})
            {
                {{ createforbody(class_name, endpoints, options) | indent(8) }}
            }
        }
    }

    {%- endif -%}
    {%- endif -%}
    {%- endfor -%}
    {% endif %}
}
