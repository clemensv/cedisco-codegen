"""
Dispatcher module for processing events from Apache Kafka.
"""

# pylint: disable=unused-import, line-too-long, missing-module-docstring, missing-function-docstring, missing-class-docstring, consider-using-f-string, trailing-whitespace, trailing-newlines

{% import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "kafka.jinja.include" as kafka -%}
{%- import "util.include.jinja" as util -%}
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = (root | exists( "format", "cloudevents" )) %}
{%- set uses_plain_kafka_message = (root | exists( "binding", "kafka" )) %}
{%- set uses_kafka_endpoint = (root | exists( "protocol", "kafka" )) %}
{%- set function_name = project_name | pascal | strip_dots -%}
import asyncio
from asyncio.events import AbstractEventLoop
import threading
from typing import Awaitable, Callable, Protocol, List, Dict, Tuple
from confluent_kafka import Consumer, KafkaException, Message
from cloudevents.abstract import CloudEvent
from cloudevents.kafka import from_binary, from_structured, KafkaMessage
{%- set messagegroups = root.messagegroups %}
{%- set imports = [] %}
{%- for messagegroup_key in messagegroups.keys() -%}
{%- set messagegroup = messagegroups[messagegroup_key] -%}
{%- for id in messagegroup.messages -%}
{%- set definition = messagegroup.messages[id] %}
{%- set type_name = util.DeclareDataType( '', root, definition ) %}
{%- if type_name != "object" %}
{%- set import_statement = "from " + (type_name | lower) + " import " + type_name | strip_namespace %}
{%- if import_statement not in imports %}
{%- set _ = imports.append(import_statement) %}
{{ import_statement }}
{%- endif %}
{%- endif %}
{%- endfor %}
{%- endfor %}

class DispatcherBase(Protocol):
    """
    Base class for dispatching events. Handles CloudEvent detection and conversion.
    """
    KAFKA_CLOUDEVENT_PREFIX = "ce_"

    @staticmethod
    def _is_cloud_event(headers: Dict[str, bytes]):
        """
        Checks if the headers indicate a CloudEvent.

        Args:
            headers: The message headers to check.

        Returns:
            True if the headers indicate a CloudEvent, False otherwise.
        """
        if "ce_id" in headers and "ce_type" in headers and "ce_source" in headers and "ce_specversion" in headers:
            return True
        elif "content-type" in headers and headers["content-type"].decode().startswith("application/cloudevents"):
            return True
        return False


    @staticmethod
    def _cloud_event_from_message(message: KafkaMessage):
        """
        Converts message to a CloudEvent.

        Args:
            message: The Kafka message to convert.

        Returns:
            A CloudEvent object.
        """
        
        if message.headers and 'content-type' in message.headers:
            content_type = message.headers['content-type'].decode()
            if content_type.startswith('application/cloudevents'):
                return from_structured(message)
            else:
                return from_binary(message)            

    class ConsumerManager:
        """ Manages a Kafka Consumer instance receive loop. """

        def __init__(self, consumer: Consumer, dispatcher: 'DispatcherBase', topics: List[str]):
            """ Initializes the ConsumerManager. """
            self.consumer = consumer
            self.dispatcher = dispatcher
            self.topics = topics
            self.running = False
            self.loop: AbstractEventLoop | None = None            
            self.thread: threading.Thread | None = None

        def __processing_loop(self, consumer, topics):
            """
            Main processing loop for the consumer.
            """
            self.loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self.loop)
            self.loop.run_until_complete(self._async_processing_loop(consumer, topics))

        async def _async_processing_loop(self, consumer, topics):
            """
            Async main processing loop for the consumer.
            """
            if self.running:
                return
            self.running = True

            try:
                consumer.subscribe(topics)
                while self.running:
                    msg = consumer.poll(timeout=1.0)
                    if msg is None:
                        continue
                    if msg.error():
                        raise KafkaException(msg.error())
                    else:
                        await self.dispatcher._process_message(msg)
            finally:
                # Close down consumer to commit final offsets.
                consumer.close()

        def run(self):
            """ Runs the consumer in a separate thread. """
            self.thread = threading.Thread(target=self.__processing_loop, args=(self.consumer, self.topics))
            self.thread.start()

        def shutdown(self):
            """ Shuts down the consumer and the event loop. """
            self.running = False
            if self.loop:
                self.loop.call_soon_threadsafe(self.loop.stop)
            if self.thread:
                self.thread.join()            

        @classmethod
        def create_consumer_manager(cls, group_id, bootstrap_servers, dispatcher, topics):
            """
            Creates a Kafka Consumer and a ConsumerManager instance.

            Args:
                group_id: The consumer group id.
                bootstrap_servers: The Kafka bootstrap servers.
                dispatcher: The dispatcher instance to handle messages.
                topics: List of topics to subscribe to.

            Returns:
                A ConsumerManager instance.
            """
            consumer = Consumer({
                'bootstrap.servers': bootstrap_servers,
                'group.id': group_id,
                'auto.offset.reset': 'earliest'
            })
            return cls(consumer, dispatcher, topics)

    def create_consumer(self, group_id: str, bootstrap_servers: List[str], topics: List[str]) -> ConsumerManager:
        """
        Creates a Kafka Consumer.

        Args:
            group_id: The consumer group id.
            bootstrap_servers: The Kafka bootstrap servers.
            dispatcher: The dispatcher instance to handle messages.

        Returns:
            A Kafka Consumer instance.
        """        
        return DispatcherBase.ConsumerManager.create_consumer_manager(group_id, bootstrap_servers, self, topics)

    async def _process_message(self, message):
        """
        Processes an incoming message.

        Args:
            message: The Kafka message to process.
        """
        

{% for messagegroup_key, messagegroup in messagegroups.items() %}
{%- set uses_cloudevents_message = (messagegroup | exists( "format", "cloudevents" )) %}
{%- set uses_plain_kafka_message = (messagegroup | existswithout( "binding", "kafka", "format", "cloudevents" )) %}
{%- set pascalGroupName = messagegroup.id | pascal %}
{%- set class_name = ( pascalGroupName | strip_namespace )+"EventDispatcher" %}

class {{ class_name }}(DispatcherBase):
    """
    Dispatcher for {{ pascalGroupName }} events.
    """
    {%- if (messagegroup | exists( "format", "cloudevents" )) %}

    {%- endif %}
    {%- for id, message in messagegroup.messages.items() %}
    {%- set definitionName = message.id | strip_namespace %}
    {%- if message.schemaurl or message.schema %}
    {%- set dataType = (message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) %}
    {%- else %}
    {%- set dataType = "object" %}
    {%- endif %}
    {%- if message.description %}
    # {{ message.description }}
    {%- endif %}
    {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) %}
    {%- set isKafka = (message | existswithout( "binding", "kafka", "format", "cloudevents" )) %}
    {{ definitionName | strip_namespace }}_async: Callable[[Message, CloudEvent, {{ dataType | strip_namespace }}], Awaitable[None]] = lambda message, cloud_event,  {{ dataType | strip_namespace }}: None

    {%- endfor %}

    async def _process_message(self, msg):
        """
        Processes an incoming message.

        Args:
            message: The Kafka message to process.
        """
        headers_dict: Dict[str, bytes] = {header[0]: header[1] for header in msg.headers()}
        message: KafkaMessage = KafkaMessage(headers = headers_dict, key = msg.key(), value = msg.value())
        if self._is_cloud_event(message.headers):
            cloud_event = self._cloud_event_from_message(message)
            await self._dispatch_cloud_event(message, cloud_event)
            return
        if message:
            await self._dispatch_message_data(message)

    async def _dispatch_cloud_event(self, message, cloud_event):
        """
        Dispatches a CloudEvent to the appropriate handler.

        Args:
            message: The original message.
            cloud_event: The CloudEvent object.
        """
        cloud_event_type = cloud_event['type']
        switcher = {
            {%- for id, message in messagegroup.messages.items() %}
            {%- set definitionName = message.id %}
            {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) %}
            {%- if message.schemaurl or message.schema %}
            {%- set dataType = (message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) %}
            {%- else %}
            {%- set dataType = "object" %}
            {%- endif %}
            "{{ message.id }}": lambda: self.{{ definitionName | strip_namespace }}_async(message, cloud_event,
            {%- if dataType != "object" %}
                {{ dataType | strip_namespace }}.from_data(cloud_event.data, cloud_event["datacontenttype"])
            {%- else %}
            cloud_event.data
            {%- endif %})
            {%- if not loop.last %}
            ,
            {%- endif %}
            {%- endfor %}
        }
        func = switcher.get(cloud_event_type, lambda: None)
        if func:
            await func()

    async def _dispatch_message_data(self, message):
        """
        Dispatches a Kafka message to the appropriate handler.

        Args:
            message: The message to dispatch.
        """
        message_subject = message.headers.get("subject")
        switcher = {
            {%- for id, message in messagegroup.messages.items() if ((message | exists("binding", "kafka" )) and not (message | exists("format", "cloudevents" ))) %}
            {%- set definitionName = message.id %}
            {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) %}
            {%- if message.schemaurl or message.schema %}
            {%- set dataType = (message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) %}
            {%- else %}
            {%- set dataType = "object" %}
            {%- endif %}
            "{{ message.id }}": lambda: self.{{ definitionName | strip_namespace }}_async(message,
            {%- if isCloudEvent %}None, {%- endif %}
            {%- if dataType != "object" %}
            {{ dataType }}.from_data(message.value(), message.headers.get('content-type'))
            {%- else %}
            message.value()
            {%- endif %})
            {%- if not loop.last %}
            ,
            {%- endif %}
            {%- endfor %}
        }
        func = switcher.get(message_subject, lambda: None)
        if func:
            await func()
{% endfor %}

{%- if root.endpoints %}
{%- for endpoint_key in root.endpoints.keys() %}
{%- set endpoint = root.endpoints[endpoint_key] %}
{%- set pascalGroupName = endpoint.id | default(endpoint_key) | pascal %}
{%- if endpoint.usage == "consumer" %}
{%- set protocol = endpoint.config.protocol | lower %}
{%- if protocol.startswith("kafka") %}
{%- set options = endpoint.config.options %}
{%- set endpoints = endpoint.config.endpoints %}
{%- set messagegroupuris = endpoint.messagegroups %}
{%- macro MessageGroupArgs() -%}
{%- for uri in messagegroupuris %}
{%- set group = schema_object( root, uri ) %}
{%- if group %}
{%- set groupname = group.id | pascal %}
{{ groupname | strip_namespace | camel }}_dispatcher=None
{%- if not loop.last -%}, {%- endif -%}
{%- endif %}
{%- endfor %}
{%- endmacro -%}
{%- macro MessageGroupHooks(arg) -%}
tasks = [
{%- for uri in messagegroupuris %}
{%- set group = schema_object( root, uri ) %}
{% if group %}
{%- set groupname = group.id | pascal %}
{{ groupname | strip_namespace | camel }}_dispatcher.process_message({{ arg }})
{%- if not loop.last -%}, {%- endif -%}
{%- endif %}
{%- endfor %}
]
await asyncio.gather(*tasks)
{%- endmacro -%}
{%- macro createforbody(class_name, endpoints, options) -%}
    {%- set kafkabrokers = endpoints[0].uri %}
    brokers = brokers or "{{ kafkabrokers }}"
    {%- if options and 'group_id' in options %}
    group_id = group_id or "{{ options['group_id'] }}"
    {%- else %}
    group_id = group_id or "default-group"
    {%- endif %}
    consumer = Consumer({
        'bootstrap.servers': brokers,
        'group.id': group_id,
        'auto.offset.reset': 'earliest'
    })
    consumer.subscribe([dispatcher])
    return consumer
{%- endmacro %}

class {{ class_name }}EventProcessorFactory:
    """
    Factory class for creating Kafka Consumer instances for {{ pascalGroupName }}.
    """

    @staticmethod
    def create_consumer_for_{{ endpoint_key | pascal | strip_namespace }}(group_id, bootstrap_servers, {{ MessageGroupArgs() }}):
        """
        Creates a Kafka Consumer for {{ endpoint_key }}.

        Args:
            group_id: The consumer group id.
            bootstrap_servers: The Kafka bootstrap servers.
            {{ MessageGroupArgs() }}: Dispatchers for message groups.

        Returns:
            A Kafka Consumer instance.
        """
        return {{ createforbody(class_name, endpoints, options) }}

{%- endif -%}
{%- endif -%}
{%- endfor %}
{%- endif -%}