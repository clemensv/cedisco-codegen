"""
Dispatcher module for processing events from Azure Event Hubs.
"""

{% import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "eventhubs.jinja.include" as eventhub -%}
{%- import "util.include.jinja" as util -%}
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = (root | exists( "format", "cloudevents" )) %}
{%- set uses_plain_amqp_message = (root | exists( "binding", "amqp" )) %}
{%- set uses_amqp_endpoint = (root | exists( "protocol", "amqp" )) %}
{%- set function_name = project_name | pascal | strip_dots -%}

import asyncio
from typing import Awaitable, Callable, Iterable, cast
from azure.eventhub.amqp import AmqpMessageBodyType
from azure.eventhub.aio import EventHubConsumerClient
from azure.eventhub import EventData, PartitionContext
from azure.eventhub.extensions.checkpointstoreblobaio import BlobCheckpointStore
from cloudevents.http import from_http, CloudEvent

{%- set messagegroups = root.messagegroups %}
{%- set imports = [] %}
{%- for messagegroup_key in messagegroups.keys() -%}
{%- set messagegroup = messagegroups[messagegroup_key] -%}
{%- for id in messagegroup.messages -%}
{%- set definition = messagegroup.messages[id] %}
{%- set type_name = util.DeclareDataType( data_project_name, root, definition ) %}
{%- if type_name != "object" %}
{%- set import_statement = "from " + (type_name | lower) + " import " + type_name | strip_namespace %}
{%- if import_statement not in imports %}
{%- set _ = imports.append(import_statement) %}
{{ import_statement }}
{%- endif %}
{%- endif %}
{%- endfor %}
{%- endfor %}

class DispatcherBase:
    """
    Base class for dispatching events. Handles CloudEvent detection and conversion.
    """
    AMQP_CLOUDEVENT_PREFIX1 = "cloudEvents_"
    AMQP_CLOUDEVENT_PREFIX2 = "cloudEvents:"

    @staticmethod
    def _strkey(key: str | bytes) -> str:
        """
        Converts a key to a string.

        Args:
            key: The key to convert.

        Returns:
            The key as a string.
        """
        if isinstance(key, bytes):
            return key.decode('utf-8')
        return key

    @staticmethod
    def _get_cloud_event_attribute(event_data: EventData, key: str):
        """
        Retrieves a CloudEvent attribute from the event data.

        Args:
            event_data: The event data containing properties.
            key: The attribute key to retrieve.

        Returns:
            The attribute value or None if not found.
        """        
        
        return event_data.properties.get((DispatcherBase.AMQP_CLOUDEVENT_PREFIX1 + key).encode('utf-8')) or \
               event_data.properties.get((DispatcherBase.AMQP_CLOUDEVENT_PREFIX2 + key).encode('utf-8'))

    @staticmethod
    def _is_cloud_event(event_data: EventData):
        """
        Checks if the event data is a CloudEvent.

        Args:
            event_data: The event data to check.

        Returns:
            True if the event data is a CloudEvent, False otherwise.
        """
        return event_data.content_type and 'application/cloudevents' in event_data.content_type or \
               any(DispatcherBase._strkey(key).startswith(DispatcherBase.AMQP_CLOUDEVENT_PREFIX1) or DispatcherBase._strkey(key).startswith(DispatcherBase.AMQP_CLOUDEVENT_PREFIX2) for key in event_data.properties)

    @staticmethod
    def _cloud_event_from_event_data(event_data: EventData):
        """
        Converts event data to a CloudEvent.

        Args:
            event_data: The event data to convert.

        Returns:
            A CloudEvent object.
        """
        headers = {
            "datacontenttype": event_data.content_type
        }
        for key_, value in event_data.properties.items():
            key = DispatcherBase._strkey(key_)
            if key.startswith(DispatcherBase.AMQP_CLOUDEVENT_PREFIX1) or key.startswith(DispatcherBase.AMQP_CLOUDEVENT_PREFIX2):
                headers[key[len(DispatcherBase.AMQP_CLOUDEVENT_PREFIX1):]] = DispatcherBase._strkey(value)
        
        if event_data.body_type == AmqpMessageBodyType.DATA:
            if isinstance(event_data.body, Iterable):
                return CloudEvent(attributes=headers, data=b''.join(event_data.body))
            else:
                return CloudEvent(attributes=headers, data=cast(bytes,event_data.body))
        elif event_data.body_type == AmqpMessageBodyType.VALUE:
            return CloudEvent(attributes=headers, data=event_data.body)
        else:
            raise NotImplementedError("CloudEvent with Sequence or Value body type is not supported")
        

class EventProcessorRunner:
    def __init__(self, client, dispatcher):
        self.client = client
        self.dispatcher = dispatcher
        self.receive_task = None

    async def __aenter__(self):
        await self.start()
        
    async def start(self):
        self.receive_task = asyncio.create_task(
            self.client.receive(on_event=self.dispatcher._process_event, starting_position="-1")
        )
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.cancel()

    async def cancel(self):
        if self.receive_task:
            self.receive_task.cancel()
            try:
                await self.receive_task
            except asyncio.CancelledError:
                pass
        await self.client.close()

{% for messagegroup_key, messagegroup in messagegroups.items() %}
{%- set uses_cloudevents_message = (messagegroup | exists( "format", "cloudevents" )) %}
{%- set uses_plain_amqp_message = (messagegroup | existswithout( "binding", "amqp", "format", "cloudevents" )) %}
{%- set pascalGroupName = messagegroup.id | pascal %}
{%- set class_name = ( pascalGroupName | strip_namespace )+"EventDispatcher" %}

class {{ class_name }}(DispatcherBase):
    """
    Dispatcher for {{ pascalGroupName }} events.
    """
    {%- for id, message in messagegroup.messages.items() %}
    {%- set definitionName = message.id | strip_namespace %}
    {%- if message.schemaurl or message.schema %}
    {%- set dataType = (message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) %}
    {%- else %}
    {%- set dataType = "object" %}
    {%- endif %}
    {%- if message.description %}
    # {{ message.description }}
    {%- endif %}
    {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) %}
    {%- set isAmqp = (message | existswithout( "binding", "amqp", "format", "cloudevents" )) %}
    {{ definitionName | strip_namespace }}_async: Callable[[PartitionContext, EventData, CloudEvent, {{ dataType | strip_namespace }}], Awaitable[None]] = lambda event, cloud_event,  {{ dataType | strip_namespace }}: Awaitable[None]

    {%- endfor %}

    async def _process_event(self, partition_context, event):
        """
        Processes an incoming event.

        Args:
            partition_context: The partition context.
            event: The event data to process.
        """
        if self._is_cloud_event(event):
            cloud_event = self._cloud_event_from_event_data(event)
            await self._dispatch_cloud_event(partition_context, event, cloud_event)
            return
        if event:
            await self._dispatch_event_data(partition_context, event)

        # Update the checkpoint so that the program doesn't read the events
        # that it has already read when you run it next time.
        await partition_context.update_checkpoint(event)

    async def _dispatch_cloud_event(self, partition_context, event, cloud_event):
        """
        Dispatches a CloudEvent to the appropriate handler.

        Args:
            partition_context: The partition context.
            event: The original event data.
            cloud_event: The CloudEvent object.
        """
        cloud_event_type = cloud_event['type']
        switcher = {
            {%- for id, message in messagegroup.messages.items() %}
            {%- set definitionName = message.id %}
            {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) %}
            {%- if message.schemaurl or message.schema %}
            {%- set dataType = (message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) %}
            {%- else %}
            {%- set dataType = "object" %}
            {%- endif %}
            "{{ message.id }}": lambda: self.{{ definitionName | strip_namespace }}_async(partition_context, event, cloud_event,
            {%- if dataType != "object" %}
                {{ dataType | strip_namespace }}.from_data(cloud_event.data, cloud_event["datacontenttype"])
            {%- else %}
            cloud_event.data
            {%- endif %})
            {%- if not loop.last %}
            ,
            {%- endif %}
            {%- endfor %}
        }
        func = switcher.get(cloud_event_type, lambda: None)
        if func:
            await func()

    async def _dispatch_event_data(self, partition_context, event):
        """
        Dispatches an AMQP event to the appropriate handler.

        Args:
            partition_context: The partition context.
            event: The event data to dispatch.
        """
        message_subject = event.raw_amqp_message.properties.subject
        switcher = {
            {%- for id, message in messagegroup.messages.items() if ((message | exists("binding", "amqp" )) and not (message | exists("format", "cloudevents" ))) %}
            {%- set definitionName = message.id %}
            {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) %}
            {%- if message.schemaurl or message.schema %}
            {%- set dataType = (message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) %}
            {%- else %}
            {%- set dataType = "object" %}
            {%- endif %}
            "{{ message.id }}": lambda: self.{{ definitionName | strip_namespace }}_async(partition_context, event,
            {%- if isCloudEvent %}None, {%- endif %}
            {%- if dataType != "object" %}
            {{ dataType }}.from_data(event.body_as_str(), event.content_type)
            {%- else %}
            event.body_as_str()
            {%- endif %})
            {%- if not loop.last %}
            ,
            {%- endif %}
            {%- endfor %}
        }
        func = switcher.get(message_subject, lambda: None)
        if func:
            await func()

    def create_processor_from_connection_strings(self, consumer_group_name:str, connection_str:str, eventhub_name:str, blob_conn_str:str, checkpoint_container:str) -> EventProcessorRunner:
        """
        Creates an EventProcessorClient.

        Args:
            consumer_group_name: The consumer group name.
            connection_str: The connection string for the Event Hub.
            blob_conn_str: The connection string for the Blob Storage.
            checkpoint_container: The container name for checkpoints.

        Returns:
            An EventProcessorRunner instance.
        """
        checkpoint_store = BlobCheckpointStore.from_connection_string(
            blob_conn_str, checkpoint_container
        )

        # Create a consumer client for the event hub.
        client = EventHubConsumerClient.from_connection_string(
            connection_str,
            consumer_group=consumer_group_name,
            eventhub_name=eventhub_name,
            checkpoint_store=checkpoint_store,
        )
        # Create and start the receive loop task
        return EventProcessorRunner(client, self)

    def create_processor(self, consumer_group_name:str, eventhubs_fully_qualified_namespace:str, eventhub_name:str, blob_account_url:str, blob_container_name:str, credential) -> EventProcessorRunner:
        """
        Creates an EventProcessorClient.

        Args:
            consumer_group_name: The consumer group name.
            eventhubs_endpoint: The Event Hubs endpoint.
            eventhub_name: The Event Hub name.
            blob_storage_endpoint: The Blob Storage endpoint.
            blob_container_name: The container name for checkpoints.
            credential: The credential to use for authentication.

        Returns:
            An EventProcessorRunner instance.
        """
        checkpoint_store = BlobCheckpointStore(
            blob_account_url=blob_account_url,
            container_name=blob_container_name,
            credential=credential,
        )
        # Create a consumer client for the event hub.
        client = EventHubConsumerClient(
            fully_qualified_namespace=eventhubs_fully_qualified_namespace,
            eventhub_name=eventhub_name,
            consumer_group=consumer_group_name,
            checkpoint_store=checkpoint_store,
            credential=credential
        )
        return EventProcessorRunner(client, self)

    

{% endfor %}

{%- if root.endpoints %}
{%- for endpoint_key in root.endpoints.keys() %}
{%- set endpoint = root.endpoints[endpoint_key] %}
{%- set pascalGroupName = endpoint.id | default(endpoint_key) | pascal %}
{%- if endpoint.usage == "consumer" %}
{%- set protocol = endpoint.config.protocol | lower %}
{%- if protocol.startswith("amqp") %}
{%- set options = endpoint.config.options %}
{%- set endpoints = endpoint.config.endpoints %}
{%- set messagegroupuris = endpoint.messagegroups %}
{%- macro MessageGroupArgs() -%}
{%- for uri in messagegroupuris %}
{%- set group = schema_object( root, uri ) %}
{%- if group %}
{%- set groupname = group.id | pascal %}
{{ groupname | strip_namespace | camel }}_dispatcher=None
{%- if not loop.last -%}, {%- endif -%}
{%- endif %}
{%- endfor %}
{%- endmacro -%}
{%- macro MessageGroupHooks(arg) -%}
tasks = [
{%- for uri in messagegroupuris %}
{%- set group = schema_object( root, uri ) %}
{% if group %}
{%- set groupname = group.id | pascal %}
{{ groupname | strip_namespace | camel }}_dispatcher.process_event({{ arg }})
{%- if not loop.last -%}, {%- endif -%}
{%- endif %}
{%- endfor %}
]
await asyncio.gather(*tasks)
{%- endmacro -%}
{%- macro createforbody(class_name, endpoints, options) -%}
    {%- set ehnamespace = geturlhost(endpoints[0].uri) -%}
    {%- set ehtopic = geturlpath(endpoints[0].uri)[1:] -%}
    fully_qualified_namespace = fully_qualified_namespace or "{{ ehnamespace }}"
    {%- if options and 'node' in options %}
    eventhub_name = eventhub_name or "{{ options['node'] }}"
    {%- elif ehtopic %}
    eventhub_name = eventhub_name or "{{ ehtopic }}"
    {%- else %}
    if eventhub_name is None:
        raise ValueError("eventhub_name cannot be None")
    {%- endif %}
    {%- if options and 'consumer_group' in options %}
    consumer_group_name = consumer_group_name or "{{ options['consumer_group'] }}"
    {%- else %}
    consumer_group_name = consumer_group_name or "$Default"
    {%- endif %}
    client = EventHubConsumerClient.from_connection_string(
        connection_str,
        consumer_group_name,
        fully_qualified_namespace=fully_qualified_namespace,
        eventhub_name=eventhub_name
    )
    receive_task = asyncio.create_task(client.receive(on_event=lambda event: {{ MessageGroupHooks("event") }}, starting_position="-1"))
    return EventProcessorRunner(client, receive_task)
{%- endmacro %}

class {{ class_name }}EventProcessorFactory:
    """
    Factory class for creating EventProcessorClient instances for {{ pascalGroupName }}.
    """

    @staticmethod
    async def create_event_processor_client_for_{{ endpoint_key | pascal | strip_namespace }}(consumer_group_name, connection_str, blob_conn_str, checkpoint_container, {{ MessageGroupArgs() }}):
        """
        Creates an EventProcessorClient for {{ endpoint_key }}.

        Args:
            consumer_group_name: The consumer group name.
            connection_str: The connection string for the Event Hub.
            blob_conn_str: The connection string for the Blob Storage.
            checkpoint_container: The container name for checkpoints.
            {{ MessageGroupArgs() }}: Dispatchers for message groups.

        Returns:
            An EventProcessorRunner instance.
        """
        return await {{ createforbody(class_name, endpoints, options) }}

{%- endif %}
{%- endif %}
{%- endfor %}
{% endif %}
